class AsyncBoundedQueue{
    constructor(length){
        switch(length){
            case 0: throw new Error('The length of the Queue cannot be zero')
            case null: throw new Error('The length of the Queue cannot be null')
        }

        this.resolvers = [] // resolvers of promises being generated by dequeue when the queue is empty
        this.resolved_promises = []  // resolved promises being generated by enqueue
        this.max_length = length || 16
        this.blocked_promise = null // block enqueue when the queue is full
    }

    get max_size(){
        return this.max_length
    }

    //how many dequeue operations are waiting
    get dequeue_size(){
        return this.resolvers.length
    }

    //how many items are stored in the queue waiting for dequeue 
    get enqueue_size(){
        return this.resolved_promises.length
    }
    
    async enqueue(item){
        // when there are already dequeue promises waiting, a pending dequeue promise is resolved
        if(this.resolvers.length){
            this.resolvers.shift()(item)
            return 
        }
        //when the queue is full
        if(this.resolved_promises.length == this.max_length){
            await this.blocked() 
        }
        //when the queue is not full
        var new_promise = new Promise((resolve, reject)=>{
                resolve(item)})
        this.resolved_promises.push(new_promise)
        
    }
    
    async dequeue(){
        //unblock enqueue when there is blocked enqueue 
        if(this.blocked_promise){
            this.unblocked()
        }
        
        //when the queue is not empty
        if(this.resolved_promises.length){
            return await this.resolved_promises.shift()
        }
        
        //when the queue is empty
        var new_pending_promise = new Promise((resolve, reject)=>{
                this.resolvers.push(resolve)
        })
        return await new_pending_promise
    }
    
    //a pending promise is used for blocking enqueue
    blocked(){
        return new Promise((resolve)=>{
            this.blocked_promise = resolve
        })
    }
    
    // resolve a pending promise to unblock enqueue
    unblocked(){
        this.blocked_promise()
        this.blocked_promise = null
    }
}

module.exports = AsyncBoundedQueue